# How-To: Adding Custom Event Visualizations to the Recursive Agent React UI

## 1. Introduction

This document provides a guide for developers on how to extend the existing `ui-react` application for the Recursive Agent Event Logging System. The primary goal is to enable the creation of custom UI components that visualize specific `AgentEvent` types beyond the default table view.

- **Purpose**: To enable richer, more targeted insights into agent behavior by visualizing specific event types (e.g., LLM calls, tool usage, node status changes).
- **Target Audience**: Frontend developers familiar with React, Redux Toolkit (RTK Query), TypeScript, and Bootstrap.
- **Overview**: We will cover the relevant UI architecture, the process of creating a new visualization component, integrating it with the existing Redux state, and styling it using Bootstrap.

This document builds upon the information provided in `ttmp/2025-04-16/04-event-logging-system.md`.

## 2. Requirements and Specifications

### Functional Requirements

- The system must allow developers to create new React components that render data based on specific `AgentEvent` types.
- Custom visualizations should access the live stream of events received via WebSocket.
- Visualizations should integrate smoothly into the existing UI layout.
- Components should handle potential variations or missing data within event payloads gracefully.

### Technical Constraints

- Must use the existing technology stack: React, TypeScript, Redux Toolkit (RTK Query), Bootstrap.
- Must consume data from the `eventsApi` RTK Query slice, which manages the WebSocket connection and event state.
- Should follow existing coding standards and component structure within `ui-react`.

## 3. Architecture Overview (ui-react)

The `ui-react` application leverages Redux Toolkit (RTK Query) to manage the WebSocket connection and the state of received events.

```mermaid
graph LR
    A[Browser UI] --> B(React Components);
    B -- Uses Hook --> C{useGetEventsQuery};
    C -- Manages --> D[RTK Query Cache (eventsApi)];
    D -- Receives Updates --> E(WebSocket Client in eventsApi);
    E -- Connects to --> F[Backend WebSocket Server (/ws/events)];

    subgraph ui-react/src
        B --- G(App.tsx);
        B --- H(components/EventTable.tsx);
        B --- I(components/StatusIndicator.tsx);
        B --- J(features/events/eventsApi.ts);
        B --- K(store.ts);
        H -- Consumes --> C;
        I -- Consumes --> C;
        J -- Defines --> C;
        J -- Contains --> E;
        K -- Configures --> D;
    end

    style ui-react/src fill:#f9f,stroke:#333,stroke-width:2px
```

- **`features/events/eventsApi.ts`**: Defines the RTK Query API slice (`eventsApi`).
  - Includes the `getEvents` query endpoint.
  - Uses `onCacheEntryAdded` to establish and manage the WebSocket connection.
  - Listens for messages, parses them as `AgentEvent`, and updates the Redux cache (`updateCachedData`).
  - Manages the `ConnectionStatus`.
- **`store.ts`**: Configures the Redux store, including the `eventsApi` middleware and reducer.
- **React Components (e.g., `components/EventTable.tsx`)**:
  - Use the `useGetEventsQuery` hook generated by RTK Query to access the event data and connection status.
  - Select relevant data (`events`, `status`) from the hook's result.
  - Render the UI based on the selected data.

New visualization components will follow the pattern of using the `useGetEventsQuery` hook to access the shared event stream data.

## 4. Data Model (UI Perspective)

The primary data structure consumed by the UI is the result of the `useGetEventsQuery` hook, which provides an object containing:

- `events`: An array of `AgentEvent` objects (defined in `eventsApi.ts`), ordered with the most recent event first.
- `status`: The current `ConnectionStatus` (Connecting, Connected, Disconnected).
- `isLoading`, `error`: Standard RTK Query status flags.

```typescript
// From ui-react/src/features/events/eventsApi.ts
export interface AgentEvent {
  event_id: string;
  timestamp: string; // ISO 8601 format
  event_type: string;
  payload: Record<string, unknown>; // Event-specific data
  run_id: string;
}

export enum ConnectionStatus {
  Connecting = "Connecting",
  Connected = "Connected",
  Disconnected = "Disconnected",
}

// Type returned by the useGetEventsQuery hook (simplified)
type GetEventsQueryResult = {
  data?: {
    events: AgentEvent[];
    status: ConnectionStatus;
  };
  error?: FetchBaseQueryError | SerializedError;
  isLoading: boolean;
  // ... other RTK Query fields
};
```

Custom components will typically filter or map the `events` array based on `event_type` or specific payload fields.

## 5. Implementation Plan

Adding a new custom visualization component involves these steps:

1.  **[ ] Define Component Scope**: Decide which `event_type`(s) the component will visualize and what aspects of the payload are relevant.
2.  **[ ] Create Component File**: Create a new `.tsx` file in `ui-react/src/components/` (e.g., `LLMCallMonitor.tsx`).
3.  **[ ] Implement Component Logic**:
    - Import `useGetEventsQuery` from `features/events/eventsApi`.
    - Call the hook to get access to `data`, `isLoading`, `error`.
    - Extract the `events` array from `data`.
    - Filter the `events` array to get only the relevant event types.
    - Process the payload of the filtered events to extract necessary information.
    - Render the visualization using React and Bootstrap components.
4.  **[ ] Integrate into App**: Import and render the new component within `App.tsx` or another appropriate parent component.
5.  **[ ] Styling**: Apply Bootstrap classes or custom CSS for styling.

### Directory Structure Recommendation

```
ui-react/
├── src/
│   ├── app/
│   │   └── store.ts        # Redux store configuration
│   ├── components/         # Reusable UI components
│   │   ├── EventTable.tsx  # Existing table view
│   │   ├── StatusIndicator.tsx
│   │   └── LLMCallMonitor.tsx # <<< Your new component
│   ├── features/
│   │   └── events/
│   │       └── eventsApi.ts # RTK Query API slice, WebSocket logic
│   ├── App.tsx             # Main application component
│   ├── main.tsx            # Application entry point
│   └── index.css           # Global styles
├── public/
├── vite.config.ts
├── tsconfig.json
└── package.json
```

## 6. Key Feature Implementation Example: LLM Call Monitor

Let's create a simple component `LLMCallMonitor.tsx` that displays the model used and duration for the most recent `llm_call_completed` event.

```typescript
// src/components/LLMCallMonitor.tsx
import React from "react";
import { useGetEventsQuery, AgentEvent } from "../features/events/eventsApi";
import { Card, Spinner } from "react-bootstrap";

const LLMCallMonitor: React.FC = () => {
  const { data, isLoading } = useGetEventsQuery();

  // Find the most recent 'llm_call_completed' event
  const lastLlmCall = data?.events.find(
    (
      event
    ): event is AgentEvent & {
      payload: { model?: string; duration_seconds?: number };
    } => event.event_type === "llm_call_completed"
  );

  // Extract relevant payload data safely
  const model = lastLlmCall?.payload?.model ?? "N/A";
  const duration = lastLlmCall?.payload?.duration_seconds;

  if (isLoading && !data) {
    return <Spinner animation="border" size="sm" />;
  }

  return (
    <Card className="mt-3">
      <Card.Header>Last LLM Call</Card.Header>
      <Card.Body>
        {lastLlmCall ? (
          <>
            <p>
              <strong>Model:</strong> {model}
            </p>
            <p>
              <strong>Duration:</strong>
              {duration !== undefined ? ` ${duration.toFixed(2)}s` : " N/A"}
            </p>
            <small className="text-muted">
              Event ID: {lastLlmCall.event_id}
            </small>
          </>
        ) : (
          <p className="text-muted">No LLM calls completed yet.</p>
        )}
      </Card.Body>
    </Card>
  );
};

export default LLMCallMonitor;
```

**Integration into `App.tsx`:**

```typescript
// src/App.tsx
import React from "react";
import EventTable from "./components/EventTable";
import LLMCallMonitor from "./components/LLMCallMonitor"; // Import the new component
import "bootstrap/dist/css/bootstrap.min.css";
import { Container, Row, Col } from "react-bootstrap";

function App() {
  return (
    <Container fluid>
      <h1 className="my-4 text-center">
        Recursive Agent - Live Event Stream (React)
      </h1>
      <Row>
        <Col md={9}>
          <EventTable />
        </Col>
        <Col md={3}>
          {/* Render the new component */}
          <LLMCallMonitor />
          {/* Add other custom components here */}
        </Col>
      </Row>
    </Container>
  );
}

export default App;
```

## 7. UI/UX Considerations

- **Clarity**: Ensure the visualization clearly represents the intended event data. Use labels, tooltips, and legends effectively.
- **Performance**: For visualizations processing many events, optimize filtering and rendering. Consider memoization (`React.memo`) or more targeted data selection if performance becomes an issue. Avoid re-rendering the entire list for every new event if possible.
- **Responsiveness**: Use Bootstrap's grid system and responsive utilities to ensure visualizations adapt to different screen sizes.
- **Error Handling**: Display meaningful messages if expected data is missing from an event payload or if events haven't arrived yet.
- **Consistency**: Maintain a consistent visual style with the rest of the application using Bootstrap themes and components.

## 8. Deployment Strategy

Deployment is handled by the Python backend (`ws_server.py`), which serves the static files generated by `npm run build` in the `ui-react/dist` directory.

- Run `npm run build` in `ui-react/` to create production assets.
- Ensure the `ws_server.py` correctly points to the `ui-react/dist` directory.
- Start the Python server (standalone or integrated). Users access the UI via the Python server's address (e.g., `http://localhost:9999`).

## 9. Future Enhancements

- **Event Filtering/Searching**: Allow users to filter the displayed events by type, run ID, or payload content.
- **Time Range Selection**: Enable viewing events within a specific time window.
- **Interactive Graphs**: Implement dynamic graph visualizations (e.g., using `react-flow` or `vis-network`) for node status or execution flow.
- **Aggregate Statistics**: Display summary statistics (e.g., average LLM duration, tool success rate).
- **Component Library**: Create a library of reusable visualization components for different event types.

## 10. Conclusion

The `ui-react` application provides a solid foundation for monitoring Recursive Agent events. By leveraging the existing RTK Query setup for WebSocket communication and state management, developers can easily create custom React components to visualize specific event types. This extensibility allows for tailored monitoring solutions that provide deeper insights into agent execution, facilitating debugging and performance analysis. Following the steps outlined in this document, developers can effectively contribute new visualizations to enhance the observability of the agent system.
