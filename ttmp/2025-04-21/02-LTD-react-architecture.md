Read file: ui-react/src/App.tsx

Read file: ui-react/src/store.ts

Read file: ui-react/vite.config.ts

Read file: ui-react/src/assets/react.svg

Read file: ui-react/src/components/EventTable.tsx

Read file: ui-react/src/components/EventDetailModal.tsx

Read file: ui-react/src/components/StatusIndicator.tsx

Read file: ui-react/src/helpers/eventType.ts
Here is a comprehensive, engaging, and developer-friendly architecture and onboarding guide for the `@ui-react` application, based on the full exploration of the codebase.

---

# WriteHERE UI-React Application Guide

**File:** `ttmp/2025-04-21/02-LTD-react-application-guide.md`  
**Date:** 2025-04-21

_(Note: This file was generated by exploring the ui-react codebase)_

---

## 1. Purpose and Scope

Welcome to the `ui-react` frontend for the WriteHERE project! This document serves as your comprehensive guide to understanding its architecture, components, and development practices. Our primary goal is to provide a deep-dive that enables new developers, like yourself, to quickly become familiar with the codebase, understand its nuances, and start contributing effectively and confidently. We'll cover everything from the high-level project goals and technology choices to the nitty-gritty details of key components and the development workflow, ensuring a smooth onboarding experience into this real-time event visualization application.

---

## 2. Project Overview

At its core, `ui-react` is designed to provide a real-time window into the operations of a complex, recursive agent system running on the backend. It visualizes the stream of events generated by this agent as it works, offering insights into its step-by-step execution, decision-making processes (like LLM calls and tool usage), and internal state changes.

**Technology Stack Choices:**

- **React 19 & TypeScript:** Provides a modern, component-based UI foundation with the benefits of strong typing for enhanced code quality, maintainability, and reduced runtime errors.
- **Vite:** Chosen for its incredibly fast development server startup and Hot Module Replacement (HMR), leading to a highly efficient development experience.
- **Redux Toolkit (RTK) & RTK Query:** Offers a standardized and efficient way to manage global application state and handle data fetching, caching, and real-time updates (via WebSockets in our case). RTK Query significantly simplifies the logic for interacting with the backend API and WebSocket stream.
- **Bootstrap 5 & React Bootstrap:** Used for rapid UI development, providing a robust set of pre-built, responsive components (like Tables, Modals, Alerts, Badges) that can be easily integrated and customized.
- **Lucide Icons:** A clean and extensive icon set used to visually represent different event types, enhancing the UI's clarity and user experience.

**Key Features Explained:**

- **Live Event Table:** The central piece of the UI, displaying events as they arrive from the backend via WebSocket. It uses icons and color-coded badges for quick identification of event types and statuses.
- **Detailed Event Modal:** Clicking on any event row reveals a comprehensive modal view with multiple tabs (Summary, LLM Prompt/Response details when applicable, raw JSON payload, and metadata like IDs and timestamps), allowing for deep inspection of individual events.
- **Robust Type Safety:** Leveraging TypeScript and discriminated unions for event types ensures that event payloads are handled correctly and safely throughout the application.
- **Modular Design:** Code is organized logically into features, components, and helpers, promoting reusability and maintainability.

---

## 3. Directory Structure Rationale

The project follows a standard yet effective structure commonly seen in modern frontend applications, optimized for clarity and scalability:

```
ui-react/
├── src/                   # Main application source code
│   ├── assets/            # Static assets like SVGs, images - directly imported
│   ├── components/        # Reusable React components (e.g., EventTable, EventDetailModal)
│   ├── features/          # Contains domain-specific logic, grouped by feature
│   │   └── events/        # Logic related to agent events (API slice, types)
│   ├── helpers/           # Utility functions, type guards (e.g., isEventType)
│   ├── App.tsx            # Root React component, defines overall layout
│   ├── App.css            # Styles specific to the App component
│   ├── index.css          # Global CSS styles and resets
│   ├── main.tsx           # Application entry point (renders App, sets up Redux)
│   ├── store.ts           # Redux store configuration (reducers, middleware)
│   └── vite-env.d.ts      # TypeScript definitions for Vite environment variables
├── public/                # Static files served directly by Vite (e.g., vite.svg)
├── dist/                  # Production build output (generated via `npm run build`)
├── package.json           # Project metadata, dependencies, and scripts
├── vite.config.ts         # Vite build tool configuration (plugins, server proxy)
├── eslint.config.js       # ESLint configuration file
└── README.md              # General project information, setup instructions
```

- **`src/features`:** Organizes code by application feature (currently just `events`). This promotes modularity, making it easier to manage related API logic, types, and potentially feature-specific state or components in the future.
- **`src/components`:** Houses general-purpose, reusable UI components that aren't tied to a specific feature.
- **`src/helpers`:** Contains utility functions that can be used across different parts of the application.

---

## 4. Key Components and Files Deep Dive

### 4.1. Entry Points & Setup

- **`main.tsx`:** This is where the application boots up. It uses `ReactDOM.createRoot` (React 19+) to render the main `App` component into the `index.html`'s root element. Crucially, it wraps `<App />` with the Redux `<Provider store={store}>`, making the Redux store available to all components down the tree. It also imports global CSS (`index.css` and Bootstrap's CSS) and wraps the app in `<React.StrictMode>` to enable helpful development-time checks.
- **`App.tsx`:** This component defines the primary layout. It's intentionally simple, rendering a main title and the `EventTable` component within a fluid Bootstrap `Container`. It imports component-specific styles from `App.css`.

### 4.2. State Management

- **`store.ts`:** Central to the application's state is the Redux store configured here using `configureStore` from Redux Toolkit.
  - **Reducers:** It registers the reducer logic from `eventsApi` under its specific `reducerPath`. Reducers are responsible for handling state updates based on dispatched actions.
  - **Middleware:** It includes the default middleware provided by RTK (like thunk for async logic, and development checks) and importantly adds `eventsApi.middleware`. This middleware is essential for RTK Query; it manages the lifecycle of data requests, caching, subscription management, and enables features like the WebSocket integration.
  - **Type Exports:** It exports `RootState` and `AppDispatch` types, which are crucial for type-safe interaction with the Redux store throughout the application (e.g., using typed hooks like `useAppSelector` and `useAppDispatch`, although not explicitly used in the current setup which relies heavily on RTK Query hooks).

### 4.3. Features & API (The Core Logic)

- **`features/events/eventsApi.ts`:** This file is arguably the heart of the application's data handling.
  - **Type Definitions:** It meticulously defines TypeScript interfaces for all known agent event payloads (`StepStartedPayload`, `LlmCallCompletedPayload`, etc.) and the `AgentEvent` discriminated union type. This union uses the `event_type` property to allow TypeScript to correctly infer the shape of the `payload` object, which is fundamental for type safety. It also defines the `LlmMessage` type for structured prompt/response content and the `ConnectionStatus` enum.
  - **RTK Query API Slice:** It uses `createApi` to define an API slice.
    - `baseQuery`: Configured with `fetchBaseQuery`, though not heavily used as the primary data comes via WebSocket.
    - `endpoints`: Defines the `getEvents` query endpoint.
      - `query`: Specifies the initial HTTP endpoint (`/api/events`) - this could potentially be used to fetch initial historical events, although the current implementation focuses on the live stream.
      - `onCacheEntryAdded`: This is the **key function for WebSocket integration**. When a component subscribes to the `getEvents` query (via the `useGetEventsQuery` hook), this lifecycle function runs. It establishes the WebSocket connection to `/ws/events`.
        - **Connection Status:** It uses `updateCachedData` to update the `status` field in the Redux cache (Connecting -> Connected -> Disconnected).
        - **Message Handling:** The `ws.onmessage` handler parses incoming JSON messages, assumes they are `AgentEvent` objects, and uses `updateCachedData` again to _prepend_ the new event to the `events` array in the cache. This keeps the event list updated in real-time. It also limits the stored events to `maxEvents` (200).
        - **Cleanup:** The `cacheEntryRemoved` promise ensures that when the last component unsubscribes, the WebSocket connection is properly closed (`ws.close()`).
  - **Hook Export:** It automatically generates and exports the `useGetEventsQuery` hook, which components use to subscribe to the event stream and get the latest data and connection status.

### 4.4. UI Components

- **`EventTable.tsx`:** The primary view component.
  - **Data Fetching:** Calls `useGetEventsQuery()` to get the `data` (containing `events` array and `status`), `error`, and `isLoading` state from the RTK Query cache.
  - **State:** Uses `useState` to manage the `selectedEvent` and the `showModal` state for the detail modal.
  - **Rendering:**
    - Displays loading spinners or error alerts based on the query state.
    - Reverses the `events` array (`[...events].reverse()`) so that the newest events appear at the top of the table.
    - Maps over the `reversedEvents` array to render a `<tr>` for each event.
    - **Dynamic Styling:** Uses `eventTypeConfig` (mapping event types to icons from `lucide-react` and Bootstrap variant/text colors) and `statusColorMap` to dynamically style badges and text.
    - **Helper Functions:** Uses `formatTimestamp`, `getEventStep`, `getEventNodeId`, and `renderPayloadDetails` to format and display data concisely in the table rows. `renderPayloadDetails` leverages the `isEventType` type guard to safely access payload fields based on the event type.
    - **Interactivity:** An `onClick` handler on each row calls `handleEventClick` to set the `selectedEvent` and toggle the `showModal` state, opening the `EventDetailModal`.
- **`EventDetailModal.tsx`:** Provides an in-depth view of a single event.
  - **Props:** Receives the `event` object, `show` state, and `onHide` callback from `EventTable`.
  - **State:** Manages the `activeTab` using `useState`.
  - **Tabbed Interface:** Uses `react-bootstrap`'s `Modal`, `Tab.Container`, `Nav`, and `Tab.Pane` components to create the tabbed layout (Summary, Prompt, Response, JSON, Metadata).
  - **Conditional Tabs:** The `getSpecialTabs` function dynamically determines if the "Prompt" and "Response" tabs should be shown based on the event type (e.g., `llm_call_started`, `llm_call_completed`) and the presence of relevant data in the payload. This uses the `isEventType` helper.
  - **Content Rendering:**
    - `renderSummaryContent`: Renders a structured summary based on the event type, again using `isEventType` to access payload fields safely and provide context-specific details. It uses Bootstrap cards for layout.
    - LLM messages (`renderPromptMessages`) are formatted with distinct backgrounds and roles.
    - The "JSON" tab pretty-prints the entire event object using `JSON.stringify`.
    - The "Metadata" tab displays key IDs and timestamps in a simple table.
  - **Functionality:** Includes a "Copy JSON" button using `navigator.clipboard.writeText`.
- **`StatusIndicator.tsx`:** A simple component that takes the `ConnectionStatus` enum (obtained via `useGetEventsQuery` in a parent, though not directly shown in `EventTable`) and maps it to a Bootstrap `Alert` variant (success, warning, danger) to display the WebSocket connection state clearly.
- **`components/styles.css`:** Contains specific CSS rules to enhance the appearance of the event table rows (hover effect), modal content layout, and the styling for different LLM message roles (system, user, assistant) within the modal.

### 4.5. Helpers

- **`helpers/eventType.ts`:** This utility is crucial for working with the `AgentEvent` discriminated union in a type-safe manner.
  - **`isEventType<T extends KnownEventType>(type: T)`:** This function is a TypeScript _type guard_. When you call `isEventType('step_started')(someEvent)`, and it returns `true`, TypeScript _narrows_ the type of `someEvent` within that code block from the broad `AgentEvent` union to the specific `{ event_type: 'step_started'; payload: StepStartedPayload; ... }` type. This enables accessing properties like `someEvent.payload.node_goal` without TypeScript errors, as the compiler knows those properties exist for that specific event type. This avoids unsafe type assertions and improves code reliability.

---

## 5. Styling Approach

The application employs a multi-layered styling strategy:

1.  **Bootstrap Foundation:** `react-bootstrap` components and standard Bootstrap 5 CSS (`bootstrap/dist/css/bootstrap.min.css`) provide the core layout system (Grid, Containers), component primitives (Tables, Modals, Badges, Alerts), and utility classes (like `text-center`, `my-4`, `fw-medium`, `text-muted`). This accelerates development and ensures responsiveness.
2.  **Global Styles (`index.css`):** Defines base styles for the entire application, including font families, base colors (respecting light/dark mode via `prefers-color-scheme`), link styles, and basic element resets.
3.  **App-Level Styles (`App.css`):** Contains styles specific to the main application container or layout elements defined within `App.tsx`. Currently includes basic layout constraints and logo animations.
4.  **Component-Specific Styles (`components/styles.css`):** More granular styles targeting elements within specific components like the `EventTable` (e.g., row hover effects) and `EventDetailModal` (e.g., LLM message formatting, tab content spacing).

This layered approach allows for global consistency via `index.css` and Bootstrap, while enabling targeted customizations at the component level without cluttering the global scope.

---

## 6. Tooling & Scripts Explained

- **Vite (`vite.config.ts`):** The build tool and development server.
  - **`@vitejs/plugin-react`:** Enables React-specific features like Fast Refresh (HMR).
  - **Server Proxy:** The `server.proxy` configuration is vital during development. It intercepts requests made by the frontend to `/api/*` and `/ws/*` and forwards them to the backend server running on `http://localhost:9999` (and `ws://localhost:9999`). This cleverly avoids Cross-Origin Resource Sharing (CORS) errors that would otherwise occur if the frontend (served by Vite on a different port) tried to directly access the backend API.
- **TypeScript (`tsconfig.json`, `tsconfig.app.json`, `tsconfig.node.json`):** Provides static typing for the entire codebase, catching potential errors during development and improving code clarity and refactoring safety. The different `tsconfig` files handle settings for the browser app code vs. Node.js-specific configuration files (like `vite.config.ts`).
- **ESLint (`eslint.config.js`):** The linter enforces code style consistency and helps catch potential bugs or anti-patterns. The `README.md` provides instructions on how to enable stricter, type-aware linting rules for production applications.
- **`package.json` Scripts:**
  - `npm run dev`: Starts the Vite development server with HMR, proxying, etc. Your primary command during development.
  - `npm run build`: First runs `tsc -b` (TypeScript compiler in build mode to check types) and then `vite build` to create an optimized production build in the `dist/` directory.
  - `npm run lint`: Executes ESLint to check the codebase for linting errors. Should be run regularly, especially before committing code.
  - `npm run preview`: Starts a simple local server to preview the production build from the `dist/` directory. Useful for checking the final build output.

---

## 7. Development Workflow Steps

1.  **Start Backend:** Ensure the backend service (which provides the `/api/events` and `/ws/events` endpoints) is running, typically listening on `localhost:9999` as configured in the Vite proxy.
2.  **Install Dependencies:** If this is your first time or dependencies have changed, run `npm install` in the `ui-react` directory.
3.  **Start Frontend Dev Server:** Run `npm run dev`. Vite will start the development server, usually on a port like `5173`, and open the application in your default browser.
4.  **Observe Real-time Data:** As the backend agent runs and generates events, they should appear in the `EventTable` in real-time thanks to the WebSocket connection managed by RTK Query. The connection status indicator should show "Connected".
5.  **Develop & Iterate:** Make changes to components (`.tsx`), styles (`.css`), or API logic (`eventsApi.ts`). Vite's HMR should automatically update the application in your browser without requiring a full page reload in most cases, providing rapid feedback.
6.  **Debug:** Use your browser's developer tools (Console, Network tab) to inspect logs, network requests (including the WebSocket connection and messages), and component states. Add `console.log` statements as needed; they won't be removed by the build process. Check backend logs if necessary.
7.  **Lint & Build:** Periodically run `npm run lint` to check for code quality issues. Before finalizing changes, run `npm run build` to ensure the application builds successfully for production and passes type checks.

---

## 8. Key Technical Insights Elaborated

- **Event-Driven UI:** The entire user experience revolves around reacting to incoming events. This makes the UI highly dynamic and responsive to the backend's state. The architecture is built to handle this stream efficiently. Understanding the different `event_type` values and their corresponding `payload` structures is key to understanding the application's data flow.
- **Type Safety as a Foundation:** The rigorous use of TypeScript, particularly with discriminated unions (`AgentEvent`) and type guards (`isEventType`), is not just a feature but a core architectural principle. It significantly reduces the likelihood of runtime errors caused by unexpected data shapes and makes the codebase much easier and safer to refactor or extend.
- **Seamless Live Updates via RTK Query & WebSockets:** The integration between RTK Query's caching/subscription mechanism (`onCacheEntryAdded`) and the native WebSocket API is elegant. It abstracts away much of the manual complexity typically associated with managing WebSocket connections and state synchronization, allowing components to simply subscribe (`useGetEventsQuery`) and receive updates automatically.
- **Maintainability through Separation of Concerns:** The clear separation between API/data logic (`features/events/eventsApi.ts`), state management (`store.ts`), UI presentation (`components/`), and utilities (`helpers/`) makes the codebase easier to navigate, understand, test, and maintain over time. Changes in one area are less likely to unintentionally break others.

---

## 9. Actionable Next Steps for Developers

1.  **Trace the Data Flow:** Start by putting a `console.log(message)` inside the `ws.onmessage` handler in `features/events/eventsApi.ts`. Run the backend and frontend, trigger some agent activity, and observe the raw events flowing in. This provides a fundamental understanding of the data source.
2.  **Inspect Component Props:** Add logging or use React DevTools to inspect the props received by `EventTable.tsx` (especially the `data` object from `useGetEventsQuery`) and `EventDetailModal.tsx` (the `event` prop). See how the data from the Redux cache is passed down.
3.  **Understand Type Guard Usage:** Find usages of `isEventType` (e.g., in `renderPayloadDetails` in `EventTable.tsx` or `renderSummaryContent` in `EventDetailModal.tsx`). Add logging within different `if (isEventType(...) { ... })` blocks to see how it correctly narrows the type and allows access to specific payload properties.
4.  **Experiment with Rendering:** Make a small modification to how a specific event type is displayed in `renderPayloadDetails` or `renderSummaryContent`. For example, change the styling or add an extra field from the payload (ensuring it's accessed type-safely within the correct `isEventType` block).
5.  **Add a New (Mock) Event Type:** (Advanced) Try defining a new payload interface, add it to the `KnownEventType` and `AgentEvent` union in `eventsApi.ts`. Then, add rendering logic for it in `EventTable` and `EventDetailModal` using `isEventType`. You might need to temporarily modify the backend or mock a WebSocket message to test it.
6.  **Review Dependencies:** Look through `package.json` to familiarize yourself with the key libraries being used (React, Redux Toolkit, Bootstrap, Lucide, etc.).

---

## 10. Key Resources

- **Core Application Logic:**
  - `src/features/events/eventsApi.ts`: **(Primary Read)** Contains event type definitions and the core RTK Query logic for WebSocket communication.
  - `src/components/EventTable.tsx`: **(Primary Read)** Implements the main event display table and uses the `useGetEventsQuery` hook.
  - `src/components/EventDetailModal.tsx`: **(Primary Read)** Handles the detailed view of individual events with complex conditional rendering based on type.
  - `src/helpers/eventType.ts`: **(Important Utility)** Defines the critical type guard for safe event handling.
  - `src/store.ts`: Shows how the Redux store and RTK Query middleware are configured.
  - `vite.config.ts`: Essential for understanding the development server proxy setup.
- **Official Documentation:**
  - [React](https://react.dev/)
  - [TypeScript](https://www.typescriptlang.org/docs/)
  - [Redux Toolkit](https://redux-toolkit.js.org/)
  - [RTK Query (Data Fetching & Caching)](https://redux-toolkit.js.org/rtk-query/overview)
  - [RTK Query (WebSocket / Streaming Updates)](https://redux-toolkit.js.org/rtk-query/usage/streaming-updates)
  - [React Bootstrap](https://react-bootstrap.netlify.app/)
  - [Bootstrap 5](https://getbootstrap.com/docs/5.3/getting-started/introduction/)
  - [Vite](https://vitejs.dev/guide/)
  - [Lucide Icons (React)](https://lucide.dev/guide/packages/lucide-react)

---

## 11. Research & Documentation Practices

Maintaining clear documentation is crucial. As you explore, learn, or make changes:

- Continue to save significant findings, research notes, or architectural decisions related to this project in the `ttmp/YYYY-MM-DD/` directory structure, following the `0X-XXX.md` naming convention.
- If you discover discrepancies between this document and the code, or identify areas needing further clarification, please update this guide or create a new document as appropriate.

---

**Welcome to the project!**
We hope this detailed guide accelerates your understanding of the `ui-react` application. The best way to learn is often by doing, so don't hesitate to follow the "Next Steps," experiment with the code, and trace the flow of data from the WebSocket connection through RTK Query and into the React components. Happy hacking!

---
