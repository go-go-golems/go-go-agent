# Specification: XML-Like Tag Extractor for LLM Responses

## 1. Goal / Motivation

The primary goal is to create a robust Go package capable of extracting structured data encapsulated within XML-like tags from text generated by Large Language Models (LLMs). LLM responses often contain such structures (e.g., `<results>`, `<thinking_block>`) but may not conform to strict XML standards (e.g., no single root element, potentially malformed tags, missing closing tags).

This extractor needs to be more flexible than standard XML parsers and provide a structured representation of the extracted information, including tag names, attributes, content, and nesting. The existing `XMLStructuredDataExtractor` is too limited as it only extracts the content of the *first* occurrence of a single, predefined tag.

Reference Example: See `go-go-agent/goagent/examples/commands/youtube-transcript-processor.yaml` for an example prompt that instructs an LLM to output data within specific tags.

## 2. Requirements

-   **Input:** A string containing the LLM response.
-   **Output:** A structured representation of *all* top-level tags found in the input string.
-   **Tag Recognition:** Identify tags using the `<tagname ...>` and `</tagname>` syntax.
-   **Attribute Parsing:** Extract key-value attributes from opening tags (e.g., `<file name="foo.xml">`). Support quoted (single and double) and unquoted attribute values.
-   **Nesting:** Correctly identify and represent nested tags. The content of a tag should include its nested children tags as raw text. A more advanced version might return a tree structure.
-   **Malformed XML Handling:**
    -   Tolerate input without a single root element.
    -   Handle potentially missing closing tags gracefully (e.g., return the tag but indicate it's unclosed, or parse up to the point of failure). *Decision needed on exact behavior.*
    -   Handle mismatched closing tags (e.g., `<outer><inner></outer>`). *Decision needed on exact behavior.*
    -   Handle self-closing tags (`<tag/>` or `<tag />`).
-   **Content Extraction:** Capture the raw string content between the start and end tags.
-   **Positional Information (Optional but Recommended):** Provide the start and end byte indices of the tag and its content within the original input string.
-   **No Strict XML Validation:** Do not enforce rules like character escaping within content (the content should be treated as raw text).

## 3. Proposed API

```go
package xmlextractor // Or a suitable package name

import "strings"

// Attribute represents a single key-value attribute of a tag.
type Attribute struct {
	Name  string
	Value string
}

// Tag represents an extracted XML-like tag and its contents.
type Tag struct {
	Name       string      // Name of the tag (e.g., "results", "file")
	Attributes []Attribute // List of attributes found in the opening tag
	Content    string      // Raw content between the start and end tags
	RawTag     string      // The raw text of the opening tag (e.g., `<file name="foo.xml">`)
	StartIndex int         // Start byte index of the opening tag in the input string
	EndIndex   int         // End byte index following the closing tag in the input string (or len(input) if unclosed)
	IsClosed   bool        // Flag indicating if a matching closing tag was found
	Children   []Tag    // Tree structure
}

// ExtractorConfig holds configuration options for the extractor.
type ExtractorConfig struct {
	// Future options like whether to build a full tree, max depth, etc.
}

// NewExtractor creates a new extractor instance (currently stateless, but allows for future config).
func NewExtractor(config *ExtractorConfig) *Extractor {
	// Initialize extractor if needed
	return &Extractor{}
}

// Extractor is responsible for parsing the input string.
type Extractor struct {
	// Potential state like configuration
}

// Extract parses the input string and returns a slice of *top-level* tags found.
// Nested tags are part of the Content string of their parent.
func (e *Extractor) Extract(input string) ([]Tag, error) {
	// Implementation details follow in Section 4
	panic("Not implemented")
}

// Helper function to get a specific attribute value by name.
func (t *Tag) GetAttribute(name string) (string, bool) {
	for _, attr := range t.Attributes {
		if attr.Name == name {
			return attr.Value, true
		}
	}
	return "", false
}

// --- Usage Example ---

/*
func main() {
	input := `
Some text before.
<results status="ok">
  <title>Analysis Results</title>
  <data key="value">Important data here.</data>
  More text.
</results>
<ignoreMe />
Another tag: <final one="1" two='2' three >Content</final> outside.
`
	extractor := xmlextractor.NewExtractor(nil)
	tags, err := extractor.Extract(input)
	if err != nil {
		// Handle error
	}

	for _, tag := range tags {
		fmt.Printf("Found tag: %s\n", tag.Name)
		fmt.Printf("  Raw Tag: %s\n", tag.RawTag)
		fmt.Printf("  Is Closed: %t\n", tag.IsClosed)
		fmt.Printf("  Start Index: %d\n", tag.StartIndex)
		fmt.Printf("  End Index: %d\n", tag.EndIndex)
		if len(tag.Attributes) > 0 {
			fmt.Println("  Attributes:")
			for _, attr := range tag.Attributes {
				fmt.Printf("    - %s = %q\n", attr.Name, attr.Value)
			}
		}
		// Content includes nested tags as raw text
		fmt.Printf("  Content:\n --- \n %s \n --- \n", tag.Content) 

		// Print the children
		fmt.Printf("  Children:\n")
		for _, child := range tag.Children {
			fmt.Printf("    - %s\n", child.Name)
		}

		if name, ok := tag.GetAttribute("status"); ok {
			fmt.Printf("  Status Attribute: %s\n", name)
		}
		fmt.Println("---")
	}
}
*/

```

## 4. Parsing Strategy / Implementation Notes

1.  **Iteration:** Scan the input string linearly.
2.  **Tag Detection:** Look for `<` characters.
3.  **Opening Tag:**
    *   If `<` is followed by `/`, it's potentially a closing tag.
    *   If `<` is followed by a valid tag name character (alphanumeric, `:`, `_`, `-`), parse the tag name.
    *   Scan forward to find `>` or `/>` (for self-closing).
    *   Parse attributes between the tag name and the closing `>` or `/>`. Handle spaces, quotes (`"` and `'`), and unquoted values (until space or `>`/`/>`). Store attributes.
    *   Record the start index and the raw opening tag string.
    *   If self-closing (`/>`), create the `Tag` struct immediately with `IsClosed=true`, empty content, and appropriate `EndIndex`. Add it to the result list if at the top level (depth 0).
    *   If not self-closing, push the tag name and its start index onto a stack.
4.  **Closing Tag:**
    *   If `</` is found, parse the tag name.
    *   Check if the stack is non-empty and the top element matches the closing tag name.
    *   If matches:
        *   Pop the stack.
        *   Create the `Tag` struct using the popped start index, the current end index, and the content between the opening tag's `>` and the closing tag's `<`.
        *   Set `IsClosed=true`.
        *   If the stack is now empty (meaning this was a top-level tag), add the `Tag` to the result list.
    *   If not matches (or stack empty): Handle as malformed (e.g., ignore the closing tag, log a warning). *Decision needed.*
5.  **Content:** Content is the raw substring between the `>` of an opening tag and the `<` of its corresponding closing tag.
6.  **End of Input:** If the end of the input is reached and the stack is not empty, the tags on the stack are unclosed. Handle them accordingly (e.g., create `Tag` structs with `IsClosed=false` and `EndIndex=len(input)`). Add top-level unclosed tags to the result list.
7.  **Data Structure:** A simple stack (e.g., `[]string` for tag names) is sufficient to track nesting depth for identifying top-level tags.

## 5. Edge Cases / Considerations

-   **Attribute Parsing Robustness:** Need to handle various spacing, missing quotes (optional), different quote types.
-   **Malformed Tag Handling Strategy:** Define clear behavior for mismatched tags (`<a><b></a></b>`) and unclosed tags. Options:
    -   Ignore mismatched closing tags.
    -   Stop parsing at the first major error.
    -   Return partially parsed tags indicating they are unclosed/malformed. (Chosen for the API proposal with `IsClosed` flag).
-   **Performance:** For very large inputs, optimize string slicing and searching. Consider `strings.Builder` if modifications are needed (though likely not for extraction). Regex might be an alternative but can be complex and potentially slower for this kind of stateful parsing.
-   **Case Sensitivity:** Tag names and attribute names are typically case-sensitive in XML. Make an option to configure that.